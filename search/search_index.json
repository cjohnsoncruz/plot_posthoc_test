{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#plot_posthoc_test.plot_stat_annotate.add_errorbar_loc_on_posthoc","title":"<code>add_errorbar_loc_on_posthoc(posthoc_df, bar_coords, overwrite_num_loc=True)</code>","text":"<p>merges posthoc df with newly created errorbar span detection</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def add_errorbar_loc_on_posthoc(posthoc_df, bar_coords, overwrite_num_loc= True):\n    ''' merges posthoc df with newly created errorbar span detection '''\n    error_rows = []\n    success_rows = []\n    for row in posthoc_df.itertuples():\n        group_info = row.g1_num_loc#=14.125, g2_num_loc=13.5, g1_cat_loc=-0.2, g2_cat_loc=-0.1, max_group_loc_val=14.125\n        # print(row.g1_cat_loc, row.g1_num_loc,row.g2_cat_loc, row.g2_num_loc)\n        g1_row_match = get_child_df_row(row.g1_cat_loc, row.g1_num_loc, bar_coords).assign(**{'g1_cat_loc':row.g1_cat_loc, 'g1_num_loc': row.g1_num_loc}).rename({x: \"_\".join([\"g_1\",x])for x in ['child_x','child_y']},axis = 1)\n        g2_row_match = get_child_df_row(row.g2_cat_loc, row.g2_num_loc, bar_coords).assign(**{'g2_cat_loc':row.g2_cat_loc, 'g2_num_loc': row.g2_num_loc}).rename({x: \"_\".join([\"g_2\",x])for x in ['child_x','child_y']},axis = 1)\n        success_rows.append(pd.concat([g1_row_match.reset_index(drop=True), g2_row_match[g2_row_match.columns.difference(g1_row_match.columns)].reset_index(drop=True)],axis = 1))\n        if (g1_row_match.size == 0) |(g2_row_match.size == 0) :\n            error_rows.append(row.Index)\n    ebar_loc = pd.concat(success_rows)\n    assert (len(error_rows)==0), f\" len {error_rows} of error rows list\"\n    posthoc_df = posthoc_df.merge(ebar_loc, how = 'left', on = ['g1_num_loc', 'g2_num_loc', 'g1_cat_loc', 'g2_cat_loc'])\n    if overwrite_num_loc:\n        posthoc_df.loc[:, 'g1_num_loc'] = posthoc_df.apply(lambda x: x['g_1_child_y'].max(),axis = 1)\n        posthoc_df.loc[:, 'g2_num_loc'] = posthoc_df.apply(lambda x: x['g_2_child_y'].max(),axis = 1)\n    return posthoc_df\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.get_ax_children_types","title":"<code>get_ax_children_types(ax_obj)</code>","text":"<p>To- return list stating what type each child of the mplt ax object is</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def get_ax_children_types(ax_obj):\n    ''' To- return list stating what type each child of the mplt ax object is'''\n    return [type(x) for x in ax_obj.get_children()]\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.get_child_df_row","title":"<code>get_child_df_row(hue_cat_loc, hue_num_loc, bar_coords)</code>","text":"<p>non vectorized function relying on vectorized subfuunctions</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def get_child_df_row(hue_cat_loc,hue_num_loc, bar_coords):\n    ''' non vectorized function relying on vectorized subfuunctions'''\n    ##run comparisons to get bool\n    is_size_match = bar_coords.y_is_2_elem# print(is_size_match)\n    is_in_child_x_vals = bar_coords.apply(lambda x:np.round(hue_cat_loc,decimals = 2) in x.child_x,axis = 1)\n    is_hue_point_in_range_bounds = bar_coords.apply(lambda x: is_val_between_range_min_max(hue_num_loc,x.child_y),axis = 1)\n    #these need to iterate over entire DF to get complete bool made\n    bar_row_bool = is_hue_point_in_range_bounds &amp; bar_coords.y_is_2_elem &amp; is_in_child_x_vals\n    row_match = bar_coords[bar_row_bool].drop(['index','next_collection_index', 'child_index'],axis = 1)\n    return row_match\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.get_hue_errorbar_loc_dict","title":"<code>get_hue_errorbar_loc_dict(ax_input, hue_order)</code>","text":"<p>Get a dictionary of the data errorbars at each level of the hue variable.</p> <p>Parameters: ax_input (matplotlib.axes.Axes): The input axis object. hue_order (list): The order of the hue in a list.</p> <p>Returns: dict: Dictionary with hue errorbar  locations.</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def get_hue_errorbar_loc_dict(ax_input, hue_order):\n    \"\"\" \n    Get a dictionary of the data errorbars at each level of the hue variable.\n\n    Parameters:\n    ax_input (matplotlib.axes.Axes): The input axis object.\n    hue_order (list): The order of the hue in a list.\n\n    Returns:\n    dict: Dictionary with hue errorbar  locations.\n    \"\"\"\n    hue_point_loc_dict = [{'hue': hue_order[count],\n                            'data_locs':x.get_offsets().data} for count, x in enumerate(ax_input.collections)]\n    return hue_point_loc_dict\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.get_hue_loc_on_axis","title":"<code>get_hue_loc_on_axis(hue_loc_df, posthoc_df, detect_error_bar=False)</code>","text":"<p>Add numerical and categorical axis locations to the posthoc comparison dataframe. Main function creating/label numeric loc on axis  NEW (2.6.25)- add detect errorbar  to automatically detect errorbar, and move point marked for symbol loc if so  Parameters: hue_loc_df (pandas.DataFrame): DataFrame with hue locations. posthoc_df (pandas.DataFrame): DataFrame with posthoc comparisons.</p> <p>Returns: pandas.DataFrame: Updated DataFrame with axis locations.</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def get_hue_loc_on_axis(hue_loc_df, posthoc_df, detect_error_bar = False): \n    \"\"\" \n    Add numerical and categorical axis locations to the posthoc comparison dataframe. Main function creating/label numeric loc on axis \n    NEW (2.6.25)- add detect errorbar  to automatically detect errorbar, and move point marked for symbol loc if so \n    Parameters:\n    hue_loc_df (pandas.DataFrame): DataFrame with hue locations.\n    posthoc_df (pandas.DataFrame): DataFrame with posthoc comparisons.\n\n    Returns:\n    pandas.DataFrame: Updated DataFrame with axis locations.\n    \"\"\"\n    \"\"\" given hue_loc_df listing where each point for the given hue categories are located, use the pre-existing post hoc comparison df\n    and add a new column to dataframe indicating y/numerical ax loc for each comparison \n    g1/2_num_loc: the value of position of group 1/2 (usually on the y axis) on the numerical axis used\n    g1/2_cat_loc: the value of point of group 1/2 (usually on the x axis) on the categorical axis used\n    group_1/2_order_pos is used to to know what the values are \"\"\"\n        ## get loc of points on the numerical ax (usually y but not always)\n        #index into hueloc df, with index = hue Group_1 name of posthoc df ; then, get list of point vals in collection; then, \n    posthoc_df['hue_group_1_locs'] = posthoc_df.apply(lambda x: hue_loc_df.loc[x['group_1']], axis = 1) #elem index = what x tick num elem is centered on\n    posthoc_df['hue_group_2_locs'] = posthoc_df.apply(lambda x: hue_loc_df.loc[x['group_2']], axis = 1) #elem index = what x tick num elem is centered on\n    posthoc_df['g1_num_loc'] = posthoc_df.apply(lambda x: x['hue_group_1_locs'][x['group_1_order_pos'][0],1], axis = 1) #x['group_1_order_pos'][0] = position of group 1 being used, in ordered list of collections \n    posthoc_df['g2_num_loc'] = posthoc_df.apply(lambda x: x['hue_group_2_locs'][x['group_2_order_pos'][0],1], axis = 1) #x['group_1_order_pos'][0] = position of group 1 being used, in ordered list of collections \n\n    ## get location of poitns on the categorical axis (usually x but not always)\n    posthoc_df['g1_cat_loc'] = posthoc_df.apply(lambda x: x['hue_group_1_locs'][x['group_1_order_pos'][0],0], axis = 1) #x['group_1_order_pos'][0] = position of group 1 being used, in ordered list of collections \n    posthoc_df['g2_cat_loc'] = posthoc_df.apply(lambda x: x['hue_group_2_locs'][x['group_2_order_pos'][0],0], axis = 1) #x['group_1_order_pos'][0] = position of group 1 being used, in ordered list of collections\n    #get max of numerical ax values\n    posthoc_df['max_group_loc_val'] = posthoc_df[['g1_num_loc', 'g2_num_loc']].max(axis = 1)\n    return posthoc_df \n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.get_hue_point_loc_df","title":"<code>get_hue_point_loc_df(ax_input, hue_order)</code>","text":"<p>Get a DataFrame of the datapoints at each level of the hue variable.</p> <p>Parameters: ax_input (matplotlib.axes.Axes): The input axis object. hue_order (list): The order of the hue.</p> <p>Returns: pandas.DataFrame: DataFrame with hue point locations.</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def get_hue_point_loc_df(ax_input, hue_order):\n    \"\"\" \n    Get a DataFrame of the datapoints at each level of the hue variable.\n\n    Parameters:\n    ax_input (matplotlib.axes.Axes): The input axis object.\n    hue_order (list): The order of the hue.\n\n    Returns:\n    pandas.DataFrame: DataFrame with hue point locations.\n    \"\"\"\n    hue_loc_df = pd.DataFrame.from_dict(get_hue_point_loc_dict(ax_input, hue_order)).set_index('hue') #get array of numerical points and values for each hue level\n    return hue_loc_df\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.get_hue_point_loc_dict","title":"<code>get_hue_point_loc_dict(ax_input, hue_order)</code>","text":"<p>Get a dictionary of the datapoints at each level of the hue variable.</p> <p>Parameters: ax_input (matplotlib.axes.Axes): The input axis object. hue_order (list): The order of the hue.</p> <p>Returns: dict: Dictionary with hue point locations.</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def get_hue_point_loc_dict(ax_input, hue_order):\n    \"\"\" \n    Get a dictionary of the datapoints at each level of the hue variable.\n\n    Parameters:\n    ax_input (matplotlib.axes.Axes): The input axis object.\n    hue_order (list): The order of the hue.\n\n    Returns:\n    dict: Dictionary with hue point locations.\n    \"\"\"\n    hue_point_loc_dict = [{'hue': hue_order[count], 'data_locs':x.get_offsets().data} for count, x in enumerate(ax_input.collections)]\n    return hue_point_loc_dict\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.get_pair_stat_test_result","title":"<code>get_pair_stat_test_result(test_name, ax_category_level, group_order, group_1_name, group_2_name, data_group_1_values, data_group_2_values, ax_var_is_hue=False)</code>","text":"<p>Run statistical test on data groups.</p> <p>Parameters: test_name (str): The name of the test. ax_category_level (str): The axis category level. group_order (iterable): The order of the groups. group_1_name (str): The name of the first group. group_2_name (str): The name of the second group. data_group_1_values (numpy.ndarray): Values of the first group. data_group_2_values (numpy.ndarray): Values of the second group. ax_var_is_hue (bool, optional): Whether the axis variable is the hue. Defaults to False.</p> <p>Returns: dict: Dictionary with the statistical test results.</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def get_pair_stat_test_result(test_name, ax_category_level,group_order, group_1_name, group_2_name, data_group_1_values,data_group_2_values,ax_var_is_hue = False):\n    \"\"\" \n    Run statistical test on data groups.\n\n    Parameters:\n    test_name (str): The name of the test.\n    ax_category_level (str): The axis category level.\n    group_order (iterable): The order of the groups.\n    group_1_name (str): The name of the first group.\n    group_2_name (str): The name of the second group.\n    data_group_1_values (numpy.ndarray): Values of the first group.\n    data_group_2_values (numpy.ndarray): Values of the second group.\n    ax_var_is_hue (bool, optional): Whether the axis variable is the hue. Defaults to False.\n\n    Returns:\n    dict: Dictionary with the statistical test results.\n    \"\"\"\n    '''Run stats test on data_group_1_values and data_group_2_values (user input for test )\n    ax order- tells you what order elements in the hue category levels are spread across the ax, so you can use later for indexing'''\n    ## run stats on group values\n    stat_result= []\n    if test_name == 'custom':\n            print('custom test ran')\n    elif test_name == 'MWU':\n            stat_result = stats.mannwhitneyu(data_group_1_values, data_group_2_values)\n    elif test_name == 'bootstrap_sdev_overlap':\n            stat_result = test_group_mean_separation(data_group_1_values, data_group_2_values)\n    elif test_name == '2_sample_t_test':\n            stat_result = stats.ttest_ind(data_group_1_values, data_group_2_values, equal_var = False) #equal_var = True, run 2 sample ttset, if false, run welch's test for unequal var\n    elif test_name == 'permutation_test':\n            stat_result =  run_permutation_test_on_diff_of_vector_means( data_group_1_values, data_group_2_values, 10000) #set to .values as original output is dict, and rounding a rdict fails \n    #record the stat values (mean, sem etc)     \n    if test_name == 'bootstrap_sdev_overlap':\n\n        group_mean_dict ={'group_1_mean':stat_result['group_1_mean'], 'group_1_sem':stat_result['group_1_std'],\n                            'group_2_mean':stat_result['group_2_mean'], 'group_2_sem':stat_result['group_2_std']}\n        stat_result = [stat_result['mean_diff_more_than_sdevs'], stat_result['pseudo_pvalue']]\n    else:\n        group_mean_dict = {'group_1_mean':np.nanmean(data_group_1_values), 'group_1_sem':scipy.stats.sem(data_group_1_values,nan_policy = 'omit' ),\n                            'group_2_mean':np.nanmean(data_group_2_values), 'group_2_sem':scipy.stats.sem(data_group_2_values,nan_policy = 'omit')}\n    #pack and return result dict\n    # print(group_order)\n    if ax_var_is_hue: #if x categorical ticks = hue groups, find index of group1 name in hue order\n        group_pos = {'group_1_order_pos': get_match_index_in_iterable(group_order, group_1_name),\n                   'group_2_order_pos': get_match_index_in_iterable(group_order, group_2_name)}\n    else: #else, find index of ax_category_tick name in xtick order, to pull correct point loc (say of wt-veh, at late IA tick)\n        group_pos = {'group_1_order_pos': get_match_index_in_iterable(group_order, ax_category_level),\n                   'group_2_order_pos': get_match_index_in_iterable(group_order, ax_category_level)}\n        #get where the groups being compared, are listed in the data collections f\n    result_dict = {'category_compared_within': ax_category_level, 'group_1': group_1_name, 'group_2':group_2_name,\n                   'group_1_n':data_group_1_values.shape, 'group_2_n':data_group_2_values.shape,\n                   **group_pos, **group_mean_dict,\n                    'test_name': test_name, 'stat_result': np.round(stat_result, 5), 'pvalue': stat_result[1]}\n    return result_dict\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.get_sig_bar_x_vals","title":"<code>get_sig_bar_x_vals(comparison_tuple)</code>","text":"<p>Get the x-values for the significance bar.</p> <p>Parameters: comparison_tuple (namedtuple): Tuple with comparison information.</p> <p>Returns: list: List of x-values for the significance bar.</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def get_sig_bar_x_vals(comparison_tuple):\n    \"\"\" \n    Get the x-values for the significance bar.\n\n    Parameters:\n    comparison_tuple (namedtuple): Tuple with comparison information.\n\n    Returns:\n    list: List of x-values for the significance bar.\n    \"\"\"\n    x_vals = [comparison_tuple.g1_cat_loc, comparison_tuple.g1_cat_loc,\n              comparison_tuple.g2_cat_loc, comparison_tuple.g2_cat_loc]# list the 4 x coord for points that define the line\n    return x_vals\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.get_sig_bar_y_vals","title":"<code>get_sig_bar_y_vals(bottom_val=None, line_height=1.01)</code>","text":"<p>Get the y-values for the significance bar. Parameters: bottom_val (float, optional): The bottom value for the bar. Defaults to 0.95. line_height (float, optional): The height of the line. Defaults to 1.01.</p> <p>Returns: list: List of y-values for the significance bar.</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def get_sig_bar_y_vals(bottom_val = None, line_height= 1.01):\n    \"\"\" \n    Get the y-values for the significance bar.\n    Parameters:\n    bottom_val (float, optional): The bottom value for the bar. Defaults to 0.95.\n    line_height (float, optional): The height of the line. Defaults to 1.01.\n\n    Returns:\n    list: List of y-values for the significance bar.\n    \"\"\"\n    \"\"\" comparison tuple max y value is multipled by offset factor\"\"\"\n    if bottom_val is None:\n        bottom_val = 0.95 #for ax relative point plotting\n    # bottom_val = comparison_tuple.max_group_loc_val * offset_factor #for data point plotting\n    y_vals = [bottom_val,bottom_val* line_height, bottom_val*line_height,bottom_val]# list the 4 x coord for points that define the line\n    return y_vals\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.get_x_ticks_as_df","title":"<code>get_x_ticks_as_df(ticklabel_obj)</code>","text":"<p>Get a DataFrame of the x-tick labels and their positions.</p> <p>Parameters: ticklabel_obj (list): List of tick label objects.</p> <p>Returns: pandas.DataFrame: DataFrame with x-tick labels and positions.</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def get_x_ticks_as_df(ticklabel_obj):\n    \"\"\" \n    Get a DataFrame of the x-tick labels and their positions.\n\n    Parameters:\n    ticklabel_obj (list): List of tick label objects.\n\n    Returns:\n    pandas.DataFrame: DataFrame with x-tick labels and positions.\n    \"\"\"\n    ticks_df = pd.DataFrame.from_records([{'tick_text':x.get_text(), 'tick_pos': x.get_position()} for x in ticklabel_obj])\n    return ticks_df\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.is_val_between_range_min_max","title":"<code>is_val_between_range_min_max(value, range_array)</code>","text":"<p>smple function</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def is_val_between_range_min_max(value, range_array):\n    ''' smple function'''\n    is_lessthan_max = value &lt; np.max(range_array)\n    is_greaterthan_min = value&gt; np.min(range_array)\n    return is_lessthan_max &amp; is_greaterthan_min\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.main_run_posthoc_tests_and_get_hue_loc_df","title":"<code>main_run_posthoc_tests_and_get_hue_loc_df(ax_input, plot_params, plot_obj, preset_comparisons, hue_var=None, test_name=None, hue_order=None, ax_var_is_hue=False, detect_error_bar=False)</code>","text":"<p>Run posthoc tests on all axis ticks, get hue levels for each axis tick, and join this to the dataframe produced.</p> <p>Parameters: ax_input (matplotlib.axes.Axes): The input axis object. plot_params (dict): Dictionary containing plot parameters. plot_obj (seaborn.axisgrid.FacetGrid): The plot object. preset_comparisons (list): List of preset comparisons. hue_var (str, optional): The hue variable. Defaults to None. test_name (str, optional): The name of the test. Defaults to None. hue_order (list, optional): The order of the hue. Defaults to None. ax_var_is_hue (bool, optional): Whether the axis variable is the hue. Defaults to False.</p> <p>Returns: pandas.DataFrame: DataFrame with posthoc test results and hue locations.</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def main_run_posthoc_tests_and_get_hue_loc_df(ax_input, plot_params, plot_obj, preset_comparisons,\n                                               hue_var= None, test_name = None, hue_order = None, ax_var_is_hue=False,detect_error_bar = False):\n    \"\"\" \n    Run posthoc tests on all axis ticks, get hue levels for each axis tick, and join this to the dataframe produced.\n\n    Parameters:\n    ax_input (matplotlib.axes.Axes): The input axis object.\n    plot_params (dict): Dictionary containing plot parameters.\n    plot_obj (seaborn.axisgrid.FacetGrid): The plot object.\n    preset_comparisons (list): List of preset comparisons.\n    hue_var (str, optional): The hue variable. Defaults to None.\n    test_name (str, optional): The name of the test. Defaults to None.\n    hue_order (list, optional): The order of the hue. Defaults to None.\n    ax_var_is_hue (bool, optional): Whether the axis variable is the hue. Defaults to False.\n\n    Returns:\n    pandas.DataFrame: DataFrame with posthoc test results and hue locations.\n    \"\"\"\n    if hue_var is None:\n        hue_var = plot_params['hue']\n    if hue_order is None:\n        hue_order = plot_params['hue_order']\n    if test_name is None:\n        test_name = None\n        # group_order- depends on if comparing within x axis, or within hues \n    if ax_var_is_hue: #you will use this to find the ordering of the hue collection points of interest\n        group_order = plot_params['hue_order'] #order in collection = order in hue\n    else: #if hue collection tiled over differnt x categories\n        group_order = plot_params['order'] #order in collection = order in x category\n    posthoc_df = run_posthoc_tests_on_all_ax_ticks(plot_params['data'], plot_obj = plot_obj, \n                                                   comparison_list =preset_comparisons, ax_grouping_col= plot_params['x'],\n                                                   group_order = group_order, hue_col_name=hue_var, value_col_name = plot_params['y'],\n                                                   test_name = test_name,ax_var_is_hue=ax_var_is_hue)## get df with info on post-hoc comparisons\n    hue_loc_df = get_hue_point_loc_df(ax_input, hue_order) # hue_loc_df = pd.DataFrame.from_dict(get_hue_point_loc_dict(plot_ax, geno_order)).set_index('hue') #get array of numerical points and values for each hue level\n    posthoc_df = get_hue_loc_on_axis(hue_loc_df, posthoc_df) #find pos in numerical ax of fig, then add as cols to df\n    #manually set cat compared within to single variable if hue == axis category\n    if ax_var_is_hue: #you will use this to find the ordering of the hue collection points of interest\n        posthoc_df['category_compared_within']= plot_params['x']\n\n    if detect_error_bar: #NEW_ add errorbar locs to posthoc df\n\n        print('Error bar detected, moving bounds')\n        ax_childs =plot_obj.get_children()\n        ax_child_points_index = [count for count, x in enumerate( get_ax_children_types(plot_obj)) if x is path_collection_type]\n        bar_coords =  return_ax_child_line_coor(ax_childs,ax_child_points_index)\n        posthoc_df =add_errorbar_loc_on_posthoc(posthoc_df, bar_coords)\n    return posthoc_df\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.plot_sig_bars_w_comp_df","title":"<code>plot_sig_bars_w_comp_df(ax_input, sig_comp_df, direction_to_plot=None)</code>","text":"<p>Plot significance bars with comparison dataframe.</p> <p>Parameters:    ax_input (matplotlib.axes.Axes): The input axis object.    sig_comp_df (pandas.DataFrame): DataFrame with significance comparisons.    direction_to_plot (str, optional): Direction to plot ('top_down', 'bottom_up'). Defaults to 'bottom_up'. TO- given parameters, plot vertical lines between centers of datapoints of interest (pre-sorted), with significance star (pre-calculated)</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def plot_sig_bars_w_comp_df(ax_input, sig_comp_df, direction_to_plot = None):\n    \"\"\" \n    Plot significance bars with comparison dataframe.\n\n    Parameters:\n    ax_input (matplotlib.axes.Axes): The input axis object.\n    sig_comp_df (pandas.DataFrame): DataFrame with significance comparisons.\n    direction_to_plot (str, optional): Direction to plot ('top_down', 'bottom_up'). Defaults to 'bottom_up'.\n TO- given parameters, plot vertical lines between centers of datapoints of interest (pre-sorted), with significance star (pre-calculated)\"\"\"\n    ## plotting params\n    if direction_to_plot is None:#set direction to plot ('top_down', 'bottom_up')\n        direction_to_plot = 'bottom_up'\n\n    line_height = 1.01\n    offset_constant = 0.025 #what linear amount to add\n    star_space_to_line = offset_constant/5\n    trans = matplotlib.transforms.blended_transform_factory(x_transform = ax_input.transData,y_transform = ax_input.transAxes)# the x coords of this transformation are data, and the y coord are axes\n    ## main loop over categorical ticks\n    for cat in sig_comp_df.category_compared_within:#iterate over each categorical tick value\n        top_bbox = np.array([[0, 0],[0, 0]])#initialize box location for comparison # =[lower_x, lower_y] [upper_x, upper_y]\n        for comp in sig_comp_df.loc[sig_comp_df.category_compared_within == cat,:].itertuples():\n            x_vals = get_sig_bar_x_vals(comp) # [comp.g1_cat_loc, comp.g1_cat_loc, comp.g2_cat_loc, comp.g2_cat_loc]# list the 4 x coord for points that define the line\n            y_vals =get_sig_bar_y_vals(0.95,line_height) #  [comp.max_group_loc_val, comp.max_group_loc_val * h, comp.max_group_loc_val * h, comp.max_group_loc_val] # list 4 y coord for points that define the line\n            line_overlap = (top_bbox[0,1] &gt;= y_vals[0])##check overlap with previous bounding box\n            if line_overlap: #if the top of the prev bbox overlaps with the current line, move the current line up to ABOVE top bbox\n                y_vals = get_sig_bar_y_vals(top_bbox[1,1]+offset_constant,line_height)             ## if overlaps with previous bounding box, adjust height by N\n            text_x = (x_vals[0]+ x_vals[2])*.5\n            text_y = y_vals[1] + star_space_to_line\n            #plot sig star over line\n            ax_input.plot(x_vals, y_vals, lw=annotator_default['line_width'], color = 'black', transform = trans, clip_on = False)\n            star_annot = ax_input.annotate(convert_pvalue_to_asterisks(comp.pvalue), xy = (text_x, text_y), xycoords = ('data', 'axes fraction'),\n                            ha='center', va='baseline', fontsize = 'small',)# bbox = {'boxstyle': 'Square, pad = 0.0', 'fc': 'lightblue', 'lw': 0})\n            bbox_in_ax = ax_input.transAxes.inverted().transform(star_annot.get_window_extent()) # to get ax coordinates of bounding box (transform from  Return the Bbox bounding the text, in display units.)\n            top_bbox = bbox_in_ax      #detect overlap by storing, then comparing ot previous versions\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.plot_sig_bars_w_comp_df_tight","title":"<code>plot_sig_bars_w_comp_df_tight(ax_input, sig_comp_df, direction_to_plot=None, tight=None, tight_offset=None, offset_constant=None, debug=None)</code>","text":"<p>Plot significance bars with comparison dataframe, using a tight layout. TO- given parameters, plot vertical lines between centers of datapoints of interest (pre-sorted), with significance star (pre-calculated) Parameters ax_input (matplotlib.axes.Axes): The input axis object. sig_comp_df (pandas.DataFrame): DataFrame with significance comparisons. direction_to_plot (str, optional): Direction to plot ('top_down', 'bottom_up'). Defaults to 'bottom_up'. tight (bool, optional): Whether to plot bars right above their corresponding values. Defaults to True. tight_offset (float, optional): Offset for tight layout. Defaults to 0.075. offset_constant (float, optional): Constant for offset. Defaults to 0.0225. debug (bool, optional): Whether to print debug information. Defaults to None.</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def plot_sig_bars_w_comp_df_tight(ax_input, sig_comp_df, direction_to_plot = None, tight = None, tight_offset = None, offset_constant=None, debug = None):\n    \"\"\" \n    Plot significance bars with comparison dataframe, using a tight layout.\n    TO- given parameters, plot vertical lines between centers of datapoints of interest (pre-sorted), with significance star (pre-calculated)\n    Parameters\n    ax_input (matplotlib.axes.Axes): The input axis object.\n    sig_comp_df (pandas.DataFrame): DataFrame with significance comparisons.\n    direction_to_plot (str, optional): Direction to plot ('top_down', 'bottom_up'). Defaults to 'bottom_up'.\n    tight (bool, optional): Whether to plot bars right above their corresponding values. Defaults to True.\n    tight_offset (float, optional): Offset for tight layout. Defaults to 0.075.\n    offset_constant (float, optional): Constant for offset. Defaults to 0.0225.\n    debug (bool, optional): Whether to print debug information. Defaults to None.\n    \"\"\"\n    ## plotting params    #set direction to plot ('top_down', 'bottom_up') #set whether bars are plotted right above their coresponding values, or not\n    #declare initial transforms of interest\n    transform_ax_to_data = ax_input.transAxes + ax_input.transData.inverted() #create ax-display + display-data pipe\n    transform_data_to_ax = transform_ax_to_data.inverted() # \n    #default vcalues\n    if direction_to_plot is None:\n        direction_to_plot = 'bottom_up'\n        line_start_y_pos = 0.8 #base case- plot upwards from 0.8 of ax size \n    if tight is None:\n        tight = True #set whether or not to plot bars RIGHT above datapoints\n    if tight_offset is None:\n        tight_offset = 0.075 #fraction of ax to put between the point of interest and the line of sig post-hoc\n    #params for offsetting\n    line_height = 1.00 #base case- 1.01\n    if offset_constant is None:\n        offset_constant = 0.0225 #what linear amount to add, in AX FRACTION AMOUNT \n\n    star_space_to_line = offset_constant*0.1\n    if debug == True:\n        print(f'tight format, max_numeric_ax_value = {max_numeric_ax_value}.  start y val  = {line_start_y_pos}')\n        #transData transforms: (DATA) -&gt; (DISPLAY COORDINATES)     # transAxes transforms (AXES) -&gt; (DISPLAY)     #all transforms -&gt; display coords \n    trans = matplotlib.transforms.blended_transform_factory(x_transform = ax_input.transData,\n                                                            y_transform = ax_input.transAxes)# the x coords of this transformation are data, and the y coord are axes\n    ## main loop over categorical ticks, bottom up approach \n    for cat in sig_comp_df.category_compared_within.unique():#iterate over each categorical tick value\n        top_bbox = np.array([[0, 0],[0, 0]])#initialize box location for comparison # =[lower_x, lower_y] [upper_x, upper_y]\n        #get max y position value for each category you're doing post-hoc comparisons within\n        sig_comp_category = sig_comp_df.loc[sig_comp_df.category_compared_within == cat,:]\n        if tight:\n            max_numeric_ax_value = sig_comp_category.loc[:, ['g1_num_loc','g2_num_loc']].max().values.max()    #get max val in the group of interest you're running posthocs on (x ticks of interest)    \n            line_start_y_pos = transform_data_to_ax.transform((0,max_numeric_ax_value))[1]+tight_offset # data -&gt; axes \n            if debug == True:\n                print(f'tight format, max_numeric_ax_value = {max_numeric_ax_value}.  start y val  = {line_start_y_pos}')\n            #transData transforms: (DATA) -&gt; (DISPLAY COORDINATES)     # transAxes transforms (AXES) -&gt; (DISPLAY)     \n        for comp in sig_comp_category.itertuples():\n            x_vals = get_sig_bar_x_vals(comp) # [comp.g1_cat_loc, comp.g1_cat_loc, comp.g2_cat_loc, comp.g2_cat_loc]# list the 4 x coord for points that define the line\n            y_vals =get_sig_bar_y_vals(line_start_y_pos,line_height) #  [comp.max_group_loc_val, comp.max_group_loc_val * h, comp.max_group_loc_val * h, comp.max_group_loc_val] # list 4 y coord for points that define the line\n            #compare overlap of proposed y values, in data space \n            line_overlap = (top_bbox[1,1] &gt;= y_vals[0])##check y overlap with previous bounding box,       #top right point y val in top_box defined by [1,1]\n            if debug == True:\n                print(f\"line overlap = ({top_bbox[0,1]} &gt;= {y_vals[0]}\")\n                print(f\"line x_vals, y_vals: {x_vals, y_vals}\")\n            if line_overlap: #if the top of the prev bbox overlaps with the current line, move the current line up to ABOVE top bbox\n                y_vals = get_sig_bar_y_vals(top_bbox[1,1]+offset_constant,line_height)             ## if overlaps with previous bounding box, adjust height by N\n\n            text_x = (x_vals[0]+ x_vals[2])*.5\n            text_y = y_vals[1] + star_space_to_line#what linear amount to separate star from line, in AX FRACTION AMOUNT \n            #plot sig star over line\n            ax_input.plot(x_vals, y_vals, lw=annotator_default['line_width'], color = 'black', transform = trans, clip_on = False)\n            star_annot = ax_input.annotate(convert_pvalue_to_asterisks(comp.pvalue), xy = (text_x, text_y), xycoords = ('data', 'axes fraction'),\n                            ha='center', va='baseline', fontsize = 'x-small',fontweight = 'light')# bbox = {'boxstyle': 'Square, pad = 0.0', 'fc': 'lightblue', 'lw': 0})\n            bbox_in_ax = ax_input.transAxes.inverted().transform(star_annot.get_window_extent()) #Get the artist's bounding box in display space.\n            # ax.transData.inverted() is a matplotlib.transforms.Transform that goes from display coordinates to data coordinates\n            top_bbox = bbox_in_ax      #detect overlap by storing, then comparing ot previous versions\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.return_ax_child_line_coor","title":"<code>return_ax_child_line_coor(ax_childs, ax_child_points_index)</code>","text":"<p>Given a set of indices of the ax child objects between which to query (e.g. path collections index), find fully nonnan yvals in the lines (corresponding to the actual real vertical errorbar) and return coords</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def return_ax_child_line_coor(ax_childs, ax_child_points_index):\n    ''' Given a set of indices of the ax child objects between which to query (e.g. path collections index), find fully nonnan yvals in the lines (corresponding to the actual real vertical errorbar) and return coords'''\n    #get errorbar lims via #get non nan values\n    ci_info = []\n    for count, i in enumerate(ax_child_points_index):\n        #get range around points, looking back  \n        if count == 0:\n            range_start = 0\n        else: \n            range_start = ax_child_points_index[count-1]+1\n        range_end = i\n        # main body\n        child_range = ax_childs[range_start: range_end] #create list of ax children instances\n        #store each entry in a list of 1 dict per line obj \n        cis = [{'child_index': count + range_start ,\n                'child_x':np.round(x.get_xdata(),decimals = 2),\n                'child_y':x.get_ydata(),\n               'next_collection_index': i} for count, x in enumerate(child_range)] #each child N gets a dict N with information\n        child = pd.DataFrame.from_records(cis)\n        ci_info.append(child)\n    # ci_x = [x.get_xdata() for x in child_range] # ci_y = [x.get_ydata() for x in child_range] #old way of getting x values\n    #NEW LOGIC- drop nan rows (as those arne't real lines)\n    coords = pd.concat(ci_info).reset_index()\n    coords['y_is_nonnan'] = coords.child_y.apply(lambda x: np.logical_not(np.any(np.isnan(x))))\n    coords['y_is_2_elem'] = coords.child_y.apply(lambda x:x.size == 2)\n    drop_nan_row= True\n    if drop_nan_row:\n        coords= coords[coords['y_is_nonnan']]\n    return coords\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.run_posthoc_test_on_tick_hue_groups","title":"<code>run_posthoc_test_on_tick_hue_groups(ax_tick_data, hue_group_1, hue_group_2, ax_category_level, group_order, hue_col_name, value_cols_name, test_name=None, ax_var_is_hue=False)</code>","text":"<p>Run posthoc test on tick hue groups. Use existing dataframe filtered by the current axis levels, and perform stats on the hue groups.</p> <p>Parameters: ax_tick_data (pandas.DataFrame): The axis tick corresponding dataframe. hue_group_1 (str): The first hue group. hue_group_2 (str): The second hue group. ax_category_level (str): The axis category level. group_order (iterable): The order of the groups. hue_col_name (str): The hue column name. value_cols_name (str): The value column name. test_name (str, optional): The name of the test. Defaults to 'MWU'. ax_var_is_hue (bool, optional): Whether the axis variable is the hue. Defaults to False.</p> <p>Returns: dict: Dictionary with the posthoc test results.</p> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def run_posthoc_test_on_tick_hue_groups(ax_tick_data, hue_group_1, hue_group_2, ax_category_level,group_order,\n                                         hue_col_name, value_cols_name,test_name = None,ax_var_is_hue = False):\n    \"\"\" \n    Run posthoc test on tick hue groups. Use existing dataframe filtered by the current axis levels, and perform stats on the hue groups.\n\n    Parameters:\n    ax_tick_data (pandas.DataFrame): The axis tick corresponding dataframe.\n    hue_group_1 (str): The first hue group.\n    hue_group_2 (str): The second hue group.\n    ax_category_level (str): The axis category level.\n    group_order (iterable): The order of the groups.\n    hue_col_name (str): The hue column name.\n    value_cols_name (str): The value column name.\n    test_name (str, optional): The name of the test. Defaults to 'MWU'.\n    ax_var_is_hue (bool, optional): Whether the axis variable is the hue. Defaults to False.\n\n    Returns:\n    dict: Dictionary with the posthoc test results.\n    \"\"\"\n    ##define test to run\n    if test_name is None:\n        test_name = 'MWU'\n    ## extract groups from the dataframe containing data corresponding to the ax tick in question\n    # ax_tick_data =plot_data.loc[plot_data[ax_grouping_col] ==  ax_category_level,:]\n    data_group_1= ax_tick_data.loc[ax_tick_data[hue_col_name] == hue_group_1,:]\n    data_group_2= ax_tick_data.loc[ax_tick_data[hue_col_name] == hue_group_2,:]\n    ## get values from each grup\n    data_group_1_values = data_group_1[value_cols_name].values\n    data_group_2_values =data_group_2[value_cols_name].values\n    ## run stats on group values\n    result_dict = get_pair_stat_test_result(test_name, ax_category_level,group_order, hue_group_1, hue_group_2, data_group_1_values,data_group_2_values,ax_var_is_hue)\n    return result_dict\n</code></pre>"},{"location":"api/#plot_posthoc_test.plot_stat_annotate.run_posthoc_tests_on_all_ax_ticks","title":"<code>run_posthoc_tests_on_all_ax_ticks(plot_data, plot_obj, comparison_list, ax_grouping_col, group_order, hue_col_name, value_col_name, test_name=None, ax_var_is_hue=False)</code>","text":"<p>Run posthoc tests on all axis ticks.</p> <p>Parameters: plot_data (pandas.DataFrame): The plot data. plot_obj (seaborn.axisgrid.FacetGrid): The plot object. comparison_list (list): List of comparisons. ax_grouping_col (str): The column name for axis grouping. group_order (iterable): The order of the groups. hue_col_name (str): The hue column name. value_col_name (str): The value column name. test_name (str, optional): The name of the test. Defaults to 'MWU'. ax_var_is_hue (bool, optional): Whether the axis variable is the hue. Defaults to False.</p> <pre><code>Returns: pandas.DataFrame: DataFrame with posthoc test results.\n</code></pre> Source code in <code>plot_posthoc_test\\plot_stat_annotate.py</code> <pre><code>def run_posthoc_tests_on_all_ax_ticks(plot_data, plot_obj, comparison_list, ax_grouping_col, group_order, hue_col_name, value_col_name,\n                                      test_name = None, ax_var_is_hue = False):\n    \"\"\" \n    Run posthoc tests on all axis ticks.\n\n    Parameters:\n    plot_data (pandas.DataFrame): The plot data.\n    plot_obj (seaborn.axisgrid.FacetGrid): The plot object.\n    comparison_list (list): List of comparisons.\n    ax_grouping_col (str): The column name for axis grouping.\n    group_order (iterable): The order of the groups.\n    hue_col_name (str): The hue column name.\n    value_col_name (str): The value column name.\n    test_name (str, optional): The name of the test. Defaults to 'MWU'.\n    ax_var_is_hue (bool, optional): Whether the axis variable is the hue. Defaults to False.\n\n        Returns: pandas.DataFrame: DataFrame with posthoc test results.\n    \"\"\"\n    if test_name is None:\n        test_name = 'MWU'\n\n    compare_stats_df = []\n    #if the ax levels = the hue levels, don't filter the plot data by what ax group col you're on\n    if ax_var_is_hue:\n\n        print(f\"With axis variable == Hue variable:\")\n        for geno_pair in comparison_list: #iterate over ex. (WT VEH to HET VEH), do stats on each\n            posthoc_output= run_posthoc_test_on_tick_hue_groups(plot_data,\n                                                                    geno_pair[0], geno_pair[1], geno_pair,group_order,\n                                                                    hue_col_name, value_col_name,test_name = test_name,ax_var_is_hue = ax_var_is_hue)\n            compare_stats_df.append(posthoc_output)\n    else:\n    #iterate through the different categories to compare hue level values within\n        for ax_category_level in plot_data[ax_grouping_col].unique():        # print(ax_category_level)\n            for geno_pair in comparison_list: #iterate over ex. (WT VEH to HET VEH), do stats on each\n                posthoc_output= run_posthoc_test_on_tick_hue_groups(plot_data.loc[plot_data[ax_grouping_col] ==  ax_category_level,:],\n                                                                    geno_pair[0], geno_pair[1], ax_category_level, group_order,\n                                                                    hue_col_name, value_col_name,test_name = test_name)\n                compare_stats_df.append(posthoc_output)\n    stat_table = pd.DataFrame.from_records(compare_stats_df)\n    # after producing stat result table, merge with df of x tick labels and their positions\n    if not(ax_var_is_hue):#transform list of xticklabels to pandas df and merge ## inserted 10.16.24- automerge the xticks\n        stat_table = stat_table.merge(get_x_ticks_as_df(plot_obj.get_xticklabels()), left_on = 'category_compared_within', right_on = 'tick_text') \n    return stat_table\n</code></pre>"}]}